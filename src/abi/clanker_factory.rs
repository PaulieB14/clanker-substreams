// @generated
// This file was @generated by `substreams-ethereum-abigen`. Do not edit it by hand.

const INTERNAL_ERR: &'static str = "`ethabi_derive` internal error";
/// Contract's functions.
#[allow(dead_code, unused_imports, unused_variables)]
pub mod functions {
    use super::INTERNAL_ERR;
}
/// Contract's events.
#[allow(dead_code, unused_imports, unused_variables)]
pub mod events {
    use super::INTERNAL_ERR;
    #[derive(Debug, Clone, PartialEq)]
    pub struct ClaimTeamFees {
        pub token: Vec<u8>,
        pub recipient: Vec<u8>,
        pub amount: substreams::scalar::BigInt,
    }
    impl ClaimTeamFees {
        const TOPIC_ID: [u8; 32] = [
            229u8,
            185u8,
            244u8,
            209u8,
            246u8,
            207u8,
            124u8,
            50u8,
            56u8,
            240u8,
            192u8,
            180u8,
            133u8,
            151u8,
            169u8,
            204u8,
            211u8,
            255u8,
            61u8,
            35u8,
            9u8,
            243u8,
            204u8,
            211u8,
            11u8,
            212u8,
            106u8,
            173u8,
            94u8,
            6u8,
            166u8,
            56u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 3usize {
                return false;
            }
            if log.data.len() != 32usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Uint(256usize)],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                token: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[1usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'token' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                recipient: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[2usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'recipient' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                amount: {
                    let mut v = [0 as u8; 32];
                    values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
            })
        }
    }
    impl substreams_ethereum::Event for ClaimTeamFees {
        const NAME: &'static str = "ClaimTeamFees";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct ExtensionTriggered {
        pub extension: Vec<u8>,
        pub extension_supply: substreams::scalar::BigInt,
        pub msg_value: substreams::scalar::BigInt,
    }
    impl ExtensionTriggered {
        const TOPIC_ID: [u8; 32] = [
            232u8,
            14u8,
            217u8,
            76u8,
            51u8,
            24u8,
            59u8,
            163u8,
            7u8,
            114u8,
            123u8,
            242u8,
            48u8,
            241u8,
            141u8,
            64u8,
            23u8,
            137u8,
            117u8,
            245u8,
            27u8,
            48u8,
            26u8,
            132u8,
            21u8,
            185u8,
            15u8,
            76u8,
            159u8,
            84u8,
            155u8,
            127u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 1usize {
                return false;
            }
            if log.data.len() != 96usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Address,
                        ethabi::ParamType::Uint(256usize),
                        ethabi::ParamType::Uint(256usize),
                    ],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                extension: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                extension_supply: {
                    let mut v = [0 as u8; 32];
                    values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
                msg_value: {
                    let mut v = [0 as u8; 32];
                    values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
            })
        }
    }
    impl substreams_ethereum::Event for ExtensionTriggered {
        const NAME: &'static str = "ExtensionTriggered";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct OwnershipTransferred {
        pub previous_owner: Vec<u8>,
        pub new_owner: Vec<u8>,
    }
    impl OwnershipTransferred {
        const TOPIC_ID: [u8; 32] = [
            139u8,
            224u8,
            7u8,
            156u8,
            83u8,
            22u8,
            89u8,
            20u8,
            19u8,
            68u8,
            205u8,
            31u8,
            208u8,
            164u8,
            242u8,
            132u8,
            25u8,
            73u8,
            127u8,
            151u8,
            34u8,
            163u8,
            218u8,
            175u8,
            227u8,
            180u8,
            24u8,
            111u8,
            107u8,
            100u8,
            87u8,
            224u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 3usize {
                return false;
            }
            if log.data.len() != 0usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            Ok(Self {
                previous_owner: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[1usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'previous_owner' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                new_owner: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[2usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'new_owner' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
            })
        }
    }
    impl substreams_ethereum::Event for OwnershipTransferred {
        const NAME: &'static str = "OwnershipTransferred";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SetAdmin {
        pub admin: Vec<u8>,
        pub enabled: bool,
    }
    impl SetAdmin {
        const TOPIC_ID: [u8; 32] = [
            85u8,
            165u8,
            25u8,
            75u8,
            192u8,
            23u8,
            79u8,
            202u8,
            241u8,
            43u8,
            41u8,
            120u8,
            190u8,
            244u8,
            57u8,
            17u8,
            70u8,
            107u8,
            246u8,
            59u8,
            52u8,
            219u8,
            141u8,
            29u8,
            209u8,
            160u8,
            213u8,
            220u8,
            213u8,
            196u8,
            27u8,
            234u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 2usize {
                return false;
            }
            if log.data.len() != 32usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Bool],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                admin: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[1usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'admin' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                enabled: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_bool()
                    .expect(INTERNAL_ERR),
            })
        }
    }
    impl substreams_ethereum::Event for SetAdmin {
        const NAME: &'static str = "SetAdmin";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SetDeprecated {
        pub deprecated: bool,
    }
    impl SetDeprecated {
        const TOPIC_ID: [u8; 32] = [
            32u8,
            219u8,
            144u8,
            103u8,
            173u8,
            25u8,
            118u8,
            247u8,
            214u8,
            238u8,
            78u8,
            224u8,
            126u8,
            234u8,
            72u8,
            193u8,
            19u8,
            158u8,
            7u8,
            22u8,
            253u8,
            133u8,
            110u8,
            198u8,
            237u8,
            242u8,
            3u8,
            35u8,
            108u8,
            55u8,
            219u8,
            130u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 1usize {
                return false;
            }
            if log.data.len() != 32usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Bool],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                deprecated: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_bool()
                    .expect(INTERNAL_ERR),
            })
        }
    }
    impl substreams_ethereum::Event for SetDeprecated {
        const NAME: &'static str = "SetDeprecated";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SetExtension {
        pub extension: Vec<u8>,
        pub enabled: bool,
    }
    impl SetExtension {
        const TOPIC_ID: [u8; 32] = [
            179u8,
            147u8,
            67u8,
            75u8,
            96u8,
            100u8,
            128u8,
            163u8,
            155u8,
            154u8,
            59u8,
            111u8,
            73u8,
            138u8,
            127u8,
            83u8,
            18u8,
            40u8,
            61u8,
            117u8,
            185u8,
            63u8,
            146u8,
            209u8,
            223u8,
            252u8,
            13u8,
            174u8,
            134u8,
            66u8,
            94u8,
            162u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 1usize {
                return false;
            }
            if log.data.len() != 64usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Address, ethabi::ParamType::Bool],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                extension: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                enabled: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_bool()
                    .expect(INTERNAL_ERR),
            })
        }
    }
    impl substreams_ethereum::Event for SetExtension {
        const NAME: &'static str = "SetExtension";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SetHook {
        pub hook: Vec<u8>,
        pub enabled: bool,
    }
    impl SetHook {
        const TOPIC_ID: [u8; 32] = [
            62u8,
            117u8,
            16u8,
            233u8,
            60u8,
            79u8,
            232u8,
            26u8,
            181u8,
            126u8,
            215u8,
            11u8,
            78u8,
            170u8,
            154u8,
            64u8,
            126u8,
            236u8,
            237u8,
            156u8,
            219u8,
            9u8,
            84u8,
            163u8,
            96u8,
            179u8,
            105u8,
            71u8,
            243u8,
            140u8,
            205u8,
            160u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 1usize {
                return false;
            }
            if log.data.len() != 64usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Address, ethabi::ParamType::Bool],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                hook: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                enabled: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_bool()
                    .expect(INTERNAL_ERR),
            })
        }
    }
    impl substreams_ethereum::Event for SetHook {
        const NAME: &'static str = "SetHook";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SetLocker {
        pub locker: Vec<u8>,
        pub pool: Vec<u8>,
        pub enabled: bool,
    }
    impl SetLocker {
        const TOPIC_ID: [u8; 32] = [
            164u8,
            43u8,
            89u8,
            90u8,
            162u8,
            158u8,
            198u8,
            55u8,
            7u8,
            79u8,
            49u8,
            83u8,
            143u8,
            191u8,
            103u8,
            53u8,
            135u8,
            215u8,
            75u8,
            164u8,
            144u8,
            38u8,
            90u8,
            51u8,
            207u8,
            4u8,
            237u8,
            65u8,
            210u8,
            122u8,
            157u8,
            220u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 1usize {
                return false;
            }
            if log.data.len() != 96usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Address,
                        ethabi::ParamType::Address,
                        ethabi::ParamType::Bool,
                    ],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                locker: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                pool: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                enabled: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_bool()
                    .expect(INTERNAL_ERR),
            })
        }
    }
    impl substreams_ethereum::Event for SetLocker {
        const NAME: &'static str = "SetLocker";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SetMevModule {
        pub mev_module: Vec<u8>,
        pub enabled: bool,
    }
    impl SetMevModule {
        const TOPIC_ID: [u8; 32] = [
            196u8,
            191u8,
            58u8,
            211u8,
            151u8,
            171u8,
            131u8,
            91u8,
            248u8,
            174u8,
            254u8,
            247u8,
            14u8,
            126u8,
            28u8,
            53u8,
            160u8,
            207u8,
            173u8,
            123u8,
            233u8,
            192u8,
            96u8,
            4u8,
            144u8,
            80u8,
            48u8,
            58u8,
            206u8,
            32u8,
            96u8,
            92u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 1usize {
                return false;
            }
            if log.data.len() != 64usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Address, ethabi::ParamType::Bool],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                mev_module: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                enabled: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_bool()
                    .expect(INTERNAL_ERR),
            })
        }
    }
    impl substreams_ethereum::Event for SetMevModule {
        const NAME: &'static str = "SetMevModule";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct SetTeamFeeRecipient {
        pub old_team_fee_recipient: Vec<u8>,
        pub new_team_fee_recipient: Vec<u8>,
    }
    impl SetTeamFeeRecipient {
        const TOPIC_ID: [u8; 32] = [
            180u8,
            167u8,
            6u8,
            54u8,
            231u8,
            164u8,
            201u8,
            210u8,
            36u8,
            187u8,
            225u8,
            51u8,
            4u8,
            1u8,
            12u8,
            203u8,
            10u8,
            201u8,
            100u8,
            179u8,
            204u8,
            70u8,
            198u8,
            18u8,
            217u8,
            171u8,
            174u8,
            172u8,
            250u8,
            32u8,
            75u8,
            217u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 1usize {
                return false;
            }
            if log.data.len() != 64usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Address, ethabi::ParamType::Address],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                old_team_fee_recipient: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                new_team_fee_recipient: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
            })
        }
    }
    impl substreams_ethereum::Event for SetTeamFeeRecipient {
        const NAME: &'static str = "SetTeamFeeRecipient";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct TokenCreated {
        pub msg_sender: Vec<u8>,
        pub token_address: Vec<u8>,
        pub token_admin: Vec<u8>,
        pub token_image: String,
        pub token_name: String,
        pub token_symbol: String,
        pub token_metadata: String,
        pub token_context: String,
        pub starting_tick: substreams::scalar::BigInt,
        pub pool_hook: Vec<u8>,
        pub pool_id: [u8; 32usize],
        pub paired_token: Vec<u8>,
        pub locker: Vec<u8>,
        pub mev_module: Vec<u8>,
        pub extensions_supply: substreams::scalar::BigInt,
        pub extensions: Vec<Vec<u8>>,
    }
    impl TokenCreated {
        const TOPIC_ID: [u8; 32] = [
            146u8,
            153u8,
            209u8,
            209u8,
            168u8,
            141u8,
            142u8,
            26u8,
            189u8,
            197u8,
            145u8,
            174u8,
            122u8,
            22u8,
            122u8,
            107u8,
            198u8,
            58u8,
            143u8,
            23u8,
            214u8,
            149u8,
            128u8,
            78u8,
            144u8,
            145u8,
            238u8,
            51u8,
            170u8,
            137u8,
            251u8,
            103u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 3usize {
                return false;
            }
            if log.data.len() < 640usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Address,
                        ethabi::ParamType::String,
                        ethabi::ParamType::String,
                        ethabi::ParamType::String,
                        ethabi::ParamType::String,
                        ethabi::ParamType::String,
                        ethabi::ParamType::Int(24usize),
                        ethabi::ParamType::Address,
                        ethabi::ParamType::FixedBytes(32usize),
                        ethabi::ParamType::Address,
                        ethabi::ParamType::Address,
                        ethabi::ParamType::Address,
                        ethabi::ParamType::Uint(256usize),
                        ethabi::ParamType::Array(Box::new(ethabi::ParamType::Address)),
                    ],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                token_address: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[1usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'token_address' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                token_admin: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[2usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'token_admin' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                msg_sender: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                token_image: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_string()
                    .expect(INTERNAL_ERR),
                token_name: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_string()
                    .expect(INTERNAL_ERR),
                token_symbol: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_string()
                    .expect(INTERNAL_ERR),
                token_metadata: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_string()
                    .expect(INTERNAL_ERR),
                token_context: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_string()
                    .expect(INTERNAL_ERR),
                starting_tick: {
                    let mut v = [0 as u8; 32];
                    values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_int()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_signed_bytes_be(&v)
                },
                pool_hook: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                pool_id: {
                    let mut result = [0u8; 32];
                    let v = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
                paired_token: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                locker: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                mev_module: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                extensions_supply: {
                    let mut v = [0 as u8; 32];
                    values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
                extensions: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_array()
                    .expect(INTERNAL_ERR)
                    .into_iter()
                    .map(|inner| {
                        inner.into_address().expect(INTERNAL_ERR).as_bytes().to_vec()
                    })
                    .collect(),
            })
        }
    }
    impl substreams_ethereum::Event for TokenCreated {
        const NAME: &'static str = "TokenCreated";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
}